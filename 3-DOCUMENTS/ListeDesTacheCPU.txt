
# En 'Live':

Génerer la PWM, avec le Timer 1.
    - Timer

Mesurer le courant tout les X millisecondes, et ajuster/limiter. (avec le capteur à effet hall)
    - Timer avec interuptions, à choisir.

Recevoir les messages CAN qui arrive toutes les Z millisecondes.
    - Voir si le CAN peut nous produire une interuption plutôt que d'avoir à vérifier en boucle
    avec un timer.
    - Si on arrive à tout traiter suffisement vite, alors pas besoin d'avoir des messages de freinage
    'prioritaire' par rapport à d'autre.

Envoyer des messages sur l'état de la carte via le CAN toutes les Y millisecondes.
    - Utiliser un timer avec Interuption.

Interuption si le driver met le PIN nfault à 0.
    - Lire les erreurs en SPI
    Agir en conséquence:
        - Recopier l'erreur sur bus CAN ?
        - Arreter la carte ? Le moteur ? ou attendre un message CAN qui nous le demande explicitement ?

# Au début:
Envoyer la config en SPI.
Lire les switchs pour savoir notre adresse/configuration.

-> Fixer une horloge, un quartz peut être ?
Fréquence max du mcu à 170 MHz. Donc à partir de là calculer toutes les fréquences des différents timers.
demander à jérome ce qu'il à estimer nécéssaire comme (plage de) fréquence de PWM.
On sait que la fréquence de la PWM du moteur sera de ~20 kHz, ce qui evitera qu'elle s'entende trop.
Donc par rapport à 170 MHz c'est un rapport de 8500.
Pour l'horloge de l'ADC, on utilisera comme source la PLL_P pour ne pas dépendre du bus AHB.
Elle est à 170 MHz, et on ne pourra pas descendre en dessous d'une division par 4.
Donc la clock de l'ADC est à 42,5 MHz.
Si l'on choisit 12 bits de précision et un sampling time de 2.5 cycles, on aurait 2.5 + 12.5 = 15 cycles d'horloges pour sampler 1 valeurs.
Donc pour faire 4 mesures (3 courrants + batterie), il nous faudra 60 cycles d'horloges, ce qui nous donne 708 kHz de fréquence d'échantillonage. (un échantillon = 4 mesures).
